#include <bits/stdc++.h>
using namespace std;

// ---- Sort ----
sort(v.begin(), v.end());               // ascending
sort(v.rbegin(), v.rend());             // descending
// custom
sort(v.begin(), v.end(), [](auto &a, auto &b){ return a.second < b.second; });

// ---- Unique ----
sort(v.begin(), v.end());
v.erase(unique(v.begin(), v.end()), v.end());

// ---- Binary Search ----
binary_search(v.begin(), v.end(), x);
auto it = lower_bound(v.begin(), v.end(), x); // first >= x
auto it2 = upper_bound(v.begin(), v.end(), x); // first > x

// ---- Stack / Queue / Deque ----
stack<int> st; st.push(1); st.top(); st.pop();
queue<int> q; q.push(1); q.front(); q.pop();
deque<int> dq; dq.push_front(2); dq.push_back(3); dq.pop_back();

// ---- Priority Queue ----
priority_queue<int> pq;                 // max-heap
priority_queue<int, vector<int>, greater<int>> minpq; // min-heap

// ---- Set / Multiset ----
set<int> s; s.insert(5); s.erase(5); if (s.count(1)) {}
multiset<int> ms; ms.insert(5); ms.erase(ms.find(5));

// ---- Map / Unordered Map ----
map<string,int> mp; mp["a"]=1;
unordered_map<string,int> ump; ump["b"]=2;

// ---- Vector ----
vector<int> v(n, 0); v.push_back(5); v.pop_back();
vector<vector<int>> grid(n, vector<int>(m, 0));

// ---- String ----
string s="abc";
reverse(s.begin(), s.end());
s.substr(1,2);           // "bc"
stoi("123"); to_string(456);

// ---- Algorithms ----
int mx = *max_element(v.begin(), v.end());
int mn = *min_element(v.begin(), v.end());
int sum = accumulate(v.begin(), v.end(), 0);
int cnt = count(v.begin(), v.end(), 5);

// ---- Fast I/O ----
ios::sync_with_stdio(false);
cin.tie(nullptr);
//Always pre-allocate vectors: vector<int> v(n+1, 0); for 1-based indexing.

//Use sort + unique for duplicate removal.

//Use queue<pair<int,int>> or stack<pair<int,int>> for grid BFS/DFS.

//Prefer unordered_map / unordered_set for faster lookups (O(1) avg).

For large input/output:


---

##  Fast I/O
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
}
```

---

##  STL Basics

### Sorting
```cpp
sort(v.begin(), v.end());               // ascending
sort(v.rbegin(), v.rend());             // descending

// custom comparator
sort(v.begin(), v.end(), [](auto &a, auto &b){
    return a.second < b.second;
});
```

### Remove Duplicates
```cpp
sort(v.begin(), v.end());
v.erase(unique(v.begin(), v.end()), v.end());
```

### Binary Search
```cpp
bool ok = binary_search(v.begin(), v.end(), x);
auto it  = lower_bound(v.begin(), v.end(), x); // first >= x
auto it2 = upper_bound(v.begin(), v.end(), x); // first > x
```

### Stack / Queue / Deque
```cpp
stack<int> st; st.push(1); st.top(); st.pop();
queue<int> q; q.push(1); q.front(); q.pop();
deque<int> dq; dq.push_back(1); dq.push_front(2); dq.pop_back();

// 2D coordinates
queue<pair<int,int>> q2;
stack<pair<int,int>> st2;
```

### Priority Queue (Heap)
```cpp
priority_queue<int> pq;   // max-heap
priority_queue<int, vector<int>, greater<int>> minpq; // min-heap
```

### Set / Multiset
```cpp
set<int> s; s.insert(5); s.erase(5); if (s.count(1)) {}
multiset<int> ms; ms.insert(5); ms.erase(ms.find(5));
```

### Map / Unordered Map
```cpp
map<string,int> mp; mp["a"] = 1;
unordered_map<string,int> ump; ump["b"] = 2;
```

### Vector
```cpp
vector<int> v(n, 0);
vector<vector<int>> grid(n, vector<int>(m, 0));
```

### String tricks
```cpp
string s = "abc";
reverse(s.begin(), s.end());
s.substr(1,2);         // "bc"
stoi("123");           // int(123)
to_string(456);        // "456"
```

### Algorithms
```cpp
int mx = *max_element(v.begin(), v.end());
int mn = *min_element(v.begin(), v.end());
int sum = accumulate(v.begin(), v.end(), 0);
int cnt = count(v.begin(), v.end(), 5);
```

---

##  Parameter Patterns (When to use what)

### 1) Pass by value — `T`
- Small, cheap to copy (int, double, small structs).

```cpp
int add(int a, int b);
```

### 2) Read-only, no copy — `const T&`
- Big objects, only read.

```cpp
int sum(const vector<int>& v);
```

### 3) Mutate caller — `T&`
- Modify caller’s data.

```cpp
void append(vector<int>& v, int x);
```

### 4) Pointer semantics — `T*` / `const T*`
- Nullable, re-targeting, C API interop.

```cpp
void maybeWrite(int* outVal);
```

### 5) Arrays
- Prefer `vector<T>&`, `array<T,N>&`, or `span<T>` (C++20).

```cpp
void f(vector<int>& a);
```

### 6) Strings
```cpp
int countA(const string& s);
void toUpper(string& s);
```

### 7) Return values
- Return by value is fine (NRVO).

```cpp
vector<int> makeRange(int n);
```

---



### References & pointers
- `T&` → reference to existing object (alias).
- `&x` → address-of operator.
- Use `const T&` for read-only, big types.
- Use `T*` when nullable or raw pointer needed.

### Strings and `' '`
- `"abc"` → char array `{'a','b','c','\0'}`
- `'a'` → single char.
- `std::string` can contain `\0` inside, `.size()` counts all.

```cpp
string s = "a\0b";
cout << s.size();    // 3
cout << s.c_str();   // prints "a"
```

### Arrays decay
```cpp
void f(int arr[], int n);   // arr becomes int*
```

### Function pointer
```cpp
int add(int a,int b){return a+b;}
int (*fp)(int,int) = add;
cout << fp(2,3);
```

---

##  Grid BFS/DFS Templates

### BFS
```cpp
queue<pair<int,int>> q;
q.push({0,0});
vector<vector<int>> dist(n, vector<int>(m,0));
dist[0][0] = 1;

int dr[4] = {-1,1,0,0}, dc[4] = {0,0,-1,1};
while(!q.empty()){
    auto [r,c] = q.front(); q.pop();
    for(int k=0;k<4;k++){
        int nr=r+dr[k], nc=c+dc[k];
        if(nr<0||nc<0||nr>=n||nc>=m) continue;
        if(grid[nr][nc]=='0'||dist[nr][nc]!=0) continue;
        dist[nr][nc]=dist[r][c]+1;
        q.push({nr,nc});
    }
}
```

### DFS (iterative)
```cpp
stack<pair<int,int>> st;
st.push({0,0});
vector<vector<bool>> vis(n, vector<bool>(m,false));

while(!st.empty()){
    auto [r,c] = st.top(); st.pop();
    if(vis[r][c]) continue;
    vis[r][c]=true;

    for(int k=0;k<4;k++){
        int nr=r+dr[k], nc=c+dc[k];
        if(nr<0||nc<0||nr>=n||nc>=m) continue;
        if(grid[nr][nc]=='0'||vis[nr][nc]) continue;
        st.push({nr,nc});
    }
}
```

---


- **Read big object** → `const T&`
- **Mutate big object** → `T&`
- **Nullable / raw interop** → `T*` / `const T*`
- **Small int/double** → `T`
- **Erase-unique** for duplicates
- **Pre-allocate vectors** with `n+1` for 1-based graphs
- **Grid traversal** → `queue<pair<int,int>>` (BFS) or `stack<pair<int,int>>` (DFS)

---
