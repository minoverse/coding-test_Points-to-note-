'U' * 3 -> "UUU" (문자열)['U'] * 3 -> ['U', 'U', 'U'] (리스트)
방법 A: 리스트끼리 더하기 (추천)
Python

# [리스트] + [리스트]
res_list = ['U'] * (len(start_path) - i) + dest_path[i:]
return ''.join(res_list)

#문자열로 처리할지, 리스트로 처리할지 헷갈릴 때 가장 안전하고 빠른 방법은 **"리스트로 다 모은 뒤 마지막에 join 한다"**. (인터뷰에서 하나만 선택!)가장 추천하는 방법은 방법 A: 리스트끼리 더하기 (추천)Python# [리스트] + [리스트]
res_list = ['U'] * (len(start_path) - i) + dest_path[i:]
return ''.join(res_list)
방법 B: 문자열끼리 더하기Python# "문자열" + "문자열"
u_part = 'U' * (len(start_path) - i)
dest_part = ''.join(dest_path[i:])
return u_part + dest_part

위상정렬(Topological Sort)
defaultdict(list)	그래프 인접 리스트 만들 때	[]
defaultdict(int)	개수를 세는 카운터, In-degree 계산할 때	0
defaultdict(set)	중복을 제거하며 데이터를 모을 때	set()

면접이나 코테에서 다음과 같은 키워드나 상황이 보이면 위상 정렬을 떠올려야 합니다.

의존성 관계: "A를 하기 위해서 B를 먼저 해야 한다"는 조건이 있을 때 (예: 선수과목, 컴파일 순서)

순서 결정: 여러 작업 사이의 우선순위가 주어지고, 전체적인 작업 순서를 정해야 할 때

사이클 없는 유향 그래프(DAG): 방향은 있지만 순환(Cycle)은 없는 구조일 때

진입 차수(In-degree): 특정 노드로 들어오는 간선의 개수를 파악하여 0인 것부터 처리해야 할 때

from collections import deque, defaultdict
h, m = map(int, time.split(':')) # : 기주능로 분리 스트링을 인트 시간 분단위로 나눠서 할당 
특징       List (리스트),                 Set (셋),                  Dictionary (딕셔너리)
구조  순서가 있는 요소들의 나열    값(Value)들의 집합               키(Key)-값(Value)의 쌍
탐색  시간O(N) (전체 탐색 필요)    O(1) (해시 테이블 활용)           O(1) (해시 테이블 활용)
중복,허용함,                          허용하지 않음                Key 중복 불가 (Value는 가능)
주요 용도,순차적 데이터 저장     "존재 여부 확인, 중복 제거"    "관계 저장, 데이터 매핑 및 조회"
선언 예시,"arr = [1, 2, 3]",      "s = set([1, 2, 3])",                   "d = {'A': 1, 'B': 2}"

1. defaultdict(dict) : 자동 초기화 딕셔너리일반 딕셔너리는 없는 키를 조회하면 KeyError가 발생합니다. 
하지만 defaultdict는 **"키가 없으면 내가 정해준 기본값으로 일단 만들어줘"**라는 뜻입니다.
graph = defaultdict(dict): "새로운 키가 들어오면 기본값으로 **빈 딕셔너리({})**를 생성해라"는 의미입니다.
왜 쓰나요? 그래프를 만들 때 a에서 b로 가는 경로를 넣으려면 graph["a"]["b"] = 2.0이라고 써야 합니다.
이때 graph["a"]가 없으면 에러가 나는데, defaultdict를 쓰면 자동으로 graph["a"] = {}를 먼저 만들어주어 코드가 매우 간결해집니다.
2. zip(equations, values) : 두 리스트를 병렬로 묶기두 개의 리스트를 마치 **지퍼(Zip)**를 올리듯이 같은 인덱스끼리 짝을 지어주는 함수입니다.
예시:equations = [["a", "b"], ["b", "c"]]values = [2.0, 3.0]zip 결과: ([["a", "b"], 2.0], [["b", "c"], 3.0]) 형태의 묶음이 됩니다.
활용: for (u, v), val in zip(equations, values): 라고 쓰면 첫 번째 루프에서 u="a", v="b", val=2.0을 한 번에 가져올 수 있습니다.
3. graph[curr].items() : 키(Key)와 값(Value) 동시 추출딕셔너리에 들어있는 데이터를 **"이름(Key)과 내용(Value)"**의 쌍으로 꺼내올 때 사용합니다.
graph[curr]: 현재 노드에 연결된 정보인 {"이웃노드": 가중치} 딕셔너리입니다..items(): 이 딕셔너리에서 (이웃노드, 가중치) 묶음들을 리스트 형태로 반환합니다.
비교:for x in graph[curr]: $\rightarrow$ x에는 **이름(neighbor)**만 들어옵니다.
for x, y in graph[curr].items(): $\rightarrow$ x에는 이름, y에는 **수치(weight)**가 들어옵니다.
defaultdict는 dict뿐만 아니라 다양한 형태로 초기화가 가능합니다! defaultdict(생성자) 괄호 안에 어떤 함수(타입)를 넣느냐에 따라 기본값이 결정됩니다.

자주 쓰이는 유형들을 정리해 드릴게요.

1. defaultdict(list) : 리스트로 초기화
가장 많이 쓰이는 형태입니다. 일대다(1:N) 관계를 만들 때 필수입니다.

용도: 그래프의 인접 리스트, 그룹화

동작: 키가 없으면 빈 리스트([])를 생성합니다. 바로 .append()를 쓸 수 있어 편리합니다.

Python

from collections import defaultdict

names = defaultdict(list)
names['성'].append('김') # '성'이라는 키가 없어도 바로 append 가능
# 결과: {'성': ['김']}
2. defaultdict(int) : 숫자로 초기화
카운터(Counter)를 만들 때 유용합니다.

용도: 개수 세기, 누적 합산

동작: 키가 없으면 숫자 0을 생성합니다. 바로 += 1을 쓸 수 있습니다.

Python

counts = defaultdict(int)
counts['사과'] += 1 # 0에서 시작해서 1이 됨
# 결과: {'사과': 1}
3. defaultdict(set) : 집합으로 초기화
중복을 허용하지 않는 관계를 만들 때 씁니다.

용도: 중복 제거된 연결 노드 관리

동작: 키가 없으면 빈 집합(set())을 생성합니다.

Python

nodes = defaultdict(set)
nodes['A'].add('B')
nodes['A'].add('B') # 중복이라 한 번만 들어감
# 결과: {'A': {'B'}}
defaultdict없는 키 접근 시 자동 생성std::map의 [] 연산자 자동 생성 기능zip리스트 두 개를 하나로 묶기두 배열을 동일한 i 인덱스로 참조하는 것items()딕셔너리 키/값 쌍 꺼내기std::map 순회 시 iterator->first, second
words.sort(key=len)
#dictonary {} key value 
def longestStrChain(self, words: List[str]) -> int:
        dp = {}
        max_chain = 0
        words.sort(key = len)
        for word in words:
            current_chain = 1
            for i in range(len(word)):
                predecessor = word[:i] + word[i+1:]
                if predecessor in dp:
                    current_chain = max(current_chain, dp[predecessor] + 1)
            dp[word] = current_chain
            max_chain = max(max_chain, current_chain)
        
        return max_chain
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        # 1. Create a dummy node to act as a handle
        dummy = ListNode(0)
        curr = dummy
        
        # 2. While both lists have nodes, pick the smaller value
        while list1 and list2:
            if list1.val <= list2.val:
                curr.next = list1
                list1 = list1.next
            else:
                curr.next = list2
                list2 = list2.next
            
            # Move our worker pointer forward
            curr = curr.next
        
        # 3. If one list runs out, attach the rest of the other list
# Move until we find a letter (Skip spaces, symbols, numbers)
while i < n and not s[i].isalpha():
    i += 1

start = i

# Move until we hit something that is NOT a letter (The end of the word)
while i < n and s[i].isalpha():
    i += 1
If you want to do it manually (without .isalpha()):
You must check the Lowercase range and the Uppercase range separately:

Python
while i < n and (('a' <= s[i] <= 'z') or ('A' <= s[i] <= 'Z')):
    i += 1
        curr.next = list1 if list1 else list2
            
        # 4. Return the head (the node after our dummy)

Reading is OK ✅
You can look at any character you want:

Python
s = "hello"
print(s[0]) # Output: "h"
2. Changing is NOT OK ❌
If you try to swap characters directly in the string, Python will throw an error:

Python
s = "hello"
s[0] = "b" # CRASH: TypeError: 'str' object does not support item assignment
3. Swapping logic comparison
Because of this "Read-Only" rule, you have to use a List to perform a swap.

The "List" way (Correct):

Python
chars = list(s) # ['h', 'e', 'l', 'l', 'o']
chars[0], chars[4] = chars[4], chars[0] # SWAP!
s = "".join(chars) # "oellh"
        return dummy.next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        curr = dummy
        
        while curr.next:
            if curr.next.val == val:
                curr.next = curr.next.next
            else:
                curr = curr.next
!!!!!sort and sorted diffrent!!!!
        nums1.sort()	sorted(nums1)
        # This ensures you return the first node that DIDN'T match 'val'
        return dummy.next
