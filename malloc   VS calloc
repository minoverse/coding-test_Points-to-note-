# ⚙️ Malloc vs. Calloc: A Comparison of Efficiency

The primary difference in efficiency between `malloc` and `calloc` stems from one function's requirement to **initialize memory to zero**.

---

## Speed and Initialization

 `malloc` (Memory Allocation) | `calloc` (Contiguous Allocation) |

| **Action** | malloc: Allocates memory. | calloc :Allocates memory **AND** initializes it to zero. |
| **Memory State** | malloc:Contains **garbage values** (uninitialized data). | calloc:Contains **zeros** (every byte set to 0). |
| **Efficiency** | malloc:**Faster.** It avoids the overhead of zeroing out the block. |calloc: **Slower.** It spends extra CPU cycles to iterate through the entire block and write a '0' to every byte. |

### Why `calloc` is Slower

`calloc` must perform an explicit **zeroing step** (similar to `memset(ptr, 0, total_size)`). This additional operation introduces overhead, making it slower than `malloc` for the same block size.

---

## Use Cases and Safety

While `malloc` is generally faster, `calloc` is often preferred when **zero-initialization is mandatory** for correctness, such as in the bitmask problem.

### When to Prefer `malloc`

* When you will **immediately and completely overwrite** every element of the allocated memory (e.g., reading data into a buffer).
* When memory contents do not need to start at zero.

### When to Prefer `calloc`

* **Bitwise Operations:** When the starting value **must be 0** (like in bitmasking) to prevent garbage values from corrupting the result.
* **Pointers and Structures:** When allocating an array of pointers or complex structures that require members to be initialized to `NULL` or zero to ensure safe operation.
* **Safety:** To prevent **undefined behavior** that occurs when reading uninitialized memory allocated by `malloc`.
